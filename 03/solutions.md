# Solutions to Day 3: Gear Ratios

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

Today's puzzle is a little bit more challenging. Maybe mostly because you need to start looking across lines within the given input, and with that you also need to do a lot of boundary checking. I didn't need a lot of code to get the answer though, just a while bunch of nested for-loops and if-statements. First, I start iterating over the lines of the input file, then over the characters within that line from left to right. Then, I check for each character if it is a digit. Subsequently, I check if I already have a `startIndex` stored (of the number I am potentially iterating over), and if not, I store the current index within the current line as the start index of a number. I need this to parse the substring containing a number to an integer value later on. Then, I check if I am on the last character of the current line, or if the next character in line isn't a digit: if so, I am on the _last_ index position of the current numeric value, and I need to start processing that.

I do that by simply 'looking around' me: iterating over the -1 x-coordinate and -1 ycoordinate, all the way up to the respective +1 coordinates on both axes. If there is any other character than a digit or a `.` in any of those 9 characters, I flip the `validNumber` boolean to `true`. Of course, for each of those checks I also need to check if I'm still within the boundaries of the input file (rows and columns) first. If the number is valid, I add it to my `answer` and reset the start index to -1 for the next number to discover.

## Part 2

This requires a little bit of a different approach. I came up with the idea of doing some prep work first. The input has its numbers divided over several columns: the number `467` takes up three columns, from index 0 to index 2. In the puzzle description, in the next row, there's a gear in the fourth column, index 3. If I would iterate over the cells around that gear, having found a digit, I also would need to start looking for the starting and end position of that number from there onwards. That would make the loop quite complex. It would be easier if the number was just there. So, in order to give myself a break, I started iterating over the input schema using my code from part one (to discover the positions of the numbers) and then parse that number into an integer, and store it in a two-dimensional array on each coordinate of the schema that the number is positioned on. So in that two-dimensional array I would store the integer value `467` in row 0 column 0, column 1 _and_ column 2. That way, when I starting looking around gears in the next step, I only need to check one cell in each wind direction and I can retrieve the number from my `numberMatrix` right away.

There's one pitfall with this though: the number `35` is positioned below the first gear, where the gear has index 3, the number `35` is stored in both index 2 and 3 on the next row. So I cannot start iterating over the 8 cells around me and just retrieve all numbers found, because there might be a duplicate in there! But this can actually only occur for the diagonals, so the solutions is easy. First check exactly above and below a given gear. If there's a number above you, there cannot be _another_ number north-west or north-east. If not, than you need to check _both_ nort-west and nort-east. Same goes for the cells below yourself. In other words: first check above, then diagonally above you. Then left and right. Then below, and only then diagonally below you. This is the part of code I'm not too proud of, as it is an ugly list of if checks and duplicate code for different index deltas. But it works and that's what counts most. Lastly, I can check if the list of numbers retrieved from looking around is exactly containing two items and if so, the gear is valid and the `answer` can be expanded with the power of both numbers.