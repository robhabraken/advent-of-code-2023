# Solutions to Day 11: Cosmic Expansion

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

I decided not to store a two-dimensional array of all of the symbols within the puzzle input, but only a list of galaxies and their positions, because that seemed to be easier to work with. And I'm glad I did, given the size explosion for part 2 later on. Also, by doing this, I have the galaxies numbered implicitely right away.

I created a class named `Galaxy` to store the x- and y-position, and added a function to calculate distances between galaxies.

Calculating the shortest distance between galaxies is surprisingly easy: it's just the sum of the differences between the x- and y-coordinates. By using the absolute value of those differences you don't have to bother with the order of the galaxies. If the galaxies are on the same axis, the difference will be 0 on that axis so the formula still works: `Abs(x1 - x2) + Abs(y1 - y2)`.

Now onto the parsing of the puzzle input. I started reading the file line by line and then iterating over the characters within that line. If the character is a '#'-symbol I created a new galaxy for that position and added it to my list. I have used a typed List\<T> so the length can be variable, while still being able to iterate over the galaxies by index. The first trick in efficiency here is that when iterating over the lines to read the puzzle input, I used a boolean for each row to keep track of if I've found a galaxy on that row. If I didn't find one after finishing that row, I knew I needed to expand that row. But instead of adding lines to the puzzle input or to a stored matrix, I simply increased my integer value named 'expandY' with one. I then continued reading the puzzle input, but I always add the value of `expandY` to the y-coordinate of the galaxy, effectively moving down any galaxy found after that moment onwards. And when it found another empty line, the value of `expandY` would become 2 and it started moving every galaxy found after that down by two positions. This corrected my y-coordinates for galaxies based on the empty rows found without increasing the size of the stored data.

Then I needed to find empty columns, which is a bit more complex. I cannot do that in the first pass of reading the puzzle input, as that parses the input line by line (or I would have to store a boolean array for all x-coordinates to keep track of that while reading the puzzle input, making the code unnecessarily complex). So I created a loop iterating over the x-coordinates of the original input. Mind that I cannot immediately change the values of the galaxies I've found, as changing the galaxy locations would invalidate my empty row discovery algorithm - I need my galaxies to stay put for now while finding empty columns. Thus, I only iterated over all of the galaxies (again, not the columns, only the galaxies stored, which is a far smaller number and comes in handy in part 2, again) and checked of any of the galaxies in my list had that specific x-coordinate. If not, I added the column number to a List\<int> collection named `emptyColumns`.

Now I could start moving over galaxies to the right. I simply iterate over the values in `emptyColumns` (which are x-coordinates). But I have to move backwards, because if I would start pushing galaxies to the right coming from the left, I may potentially come across the same galaxy in my next iteration of the loop and push it forward again... So I better start on the right (highest x-value) which is the value added to the `emptyColumns` list last and work my way back to the left. Each time I find a galaxy that has an x-coordinate that his higher than my `emptyColumn` value I know I need to increase its x-value by one. Galaxies that are east of multiple empty columns are pushed to the right multiple times that way. Again, I'm only moving galaxies by coordinates so this doesn't affect the size of my dataset.

Having expanded my comsos, I now only needed to calculate the sum of all distances. Finding unique pairs of galaxies isn't very complicated by the way. If you iterate over the list of galaxies, and then per galaxy iterate over that same list of galaxies, but you start with the galaxy index of the first loop, you automatically end up with unique pairs. E.g., for the first galaxy (1) you calculate the distance to 1, 2, 3, 4 and 5. For the second galaxy (2) you calculate the distance to 2, 3, 4 and 5. For the third, to 3, 4 and 5. Et cetera. I know that I included the distances to the galaxy itself too this way (1 to 1, 2 to 2 etc.), but this wouldn't influence the outcome anyway because that distance always is 0. And having the inner loop start at +1 would make the code more complex, because you then also need to check if you're not passing the end of the list (index out of bounds).

Because I added the `DistanceTo()` method on a galaxy object in the beginning, I now could easily get the distances between these pairs and add them to my answer. It actually takes longer to explain than to write in code, as this last part was only three lines of code.

## Part 2

When reading the puzzle description for part 2, I knew right away my approach for the first part was spot on. Because I didn't work with the matrix, but only with the galaxies, my collections wouldn't get bigger from increasing the distances. I only changed my `answer` variable type from int to long and introduced a new variable: `expansionFactor`. Instead of increasing the x- and y-coordinates by one, I increased it by the expansionFactor.

Mind though, that the first part of the puzzle says to add a row or column for each empty row or column, while the second part says to replace the empty row of column with one million (a million times larger is not the same as a million additional rows). So I've set the expansionFactor to 999999, as that is the amount of additional rows or columns to add.

As I expected, the algorithm was equally fast with the now vastly expanded comsos. 