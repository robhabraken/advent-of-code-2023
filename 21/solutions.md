# Solutions to Day 21: Step Counter

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

Today, I learned a lot about the penalty of using an Object Oriented approach. I initially thought this one wasn't too difficult, as it is just a BFS algorithm starting from the center. It took a little bit of time to understand that you also could go back to any tile you visited before, so 8 steps is also 5 steps forward and 3 steps backwards, as well as 4 steps forward and 4 steps to your right. But some experimenting showed that it actually just flips a garden plot in visitable or not based on an even or an odd number of steps. You cannot reach an odd number of tiles when taking 8 steps, but all even steps in between you can. Taking 8 steps gets you to the eight plot as counted from the start. But 7 forward and 1 back gets you to the sixth. And 6 forward and 2 back to the fourth. Et cetera. In other words, where my initial BFS also walked backwards - actually creating a much longer queue than needed, my second version just went forward and stored all distances for each plot, to count only the even steps in the end.

But still, it was super super slow. It took about an hour to find the first 34 of the 64 steps and basically didn't go past that number for a very long while. While the map is only 131 x 131 plots, which isn't a big number at all. And since you can't reach half of those (the four corners aren't reachable in 64 steps), the total amount of objects in the queue cannot exceed ~8.500. So I parked this day until after the end of AoC, and only then started reading other solutions for day 21. And as it turned out, they where exactly the same! So it wasn't my logic. Looking for optimizations I decided to drop my object oriented approach. I used a `Tile` object and a `Step` object to keep track of all the properties. A tile had an x- and y-coordinate and a distance to get to there, and also a visited boolean (which I didn't need in the end because I could just check if the distance was already set). The step had a step count and an x- and y-coordinate as well. Super clear code, but also super heavy on my garbage collector, as I was creating `Step` objects constantly to put them on the queue, only using them very briefly, dropping them almost right away when I dequeued it and went to the next tile. But I would've never imagined how big the penalty actually was!

I refactored my code: instead of using an x and y position, I used an index to indicate my position (y * width + x). This index is just an integer object, so I changed my `Queue<Step>` into a `Queue<int>`. And the step count now isn't set after getting it from the queue (so it needed to be in the step object), but it is set on the tile before I put the new location on the queue. And then, when I dequeue, I just read the number from the tile, so I don't need to store it twice. This optimization dropped all objects (the tile was replaced by a distance integer as well, as that was actually the only thing I needed). So, from two objects and an object BFS queue, to a two-dimensional integer array and an integer queue. I ran my code again with the same logic as before, and now it completed in 7 ms! For all 64 steps. I understand using objects for a queue in a BFS algorithm is a shitty idea, but I am still shocked by the difference in performance. Maybe I'll even go back over my previous solutions to see what I can win in performance for the other AoC days.

## Part 2

The numbers are so big, that you wouldn't even try to brute-force it. You just know it has to be solvable using math. And quite simple math too as it turned out - though that certainly wasn't my first impression. But because I was already scrolling through the AoC subreddit for finding the issue with my part 1 puzzle, I couldn't help but spot a very clear hint on what direction you should go. It's basically a big diamond shaped collection of maps. And you need to find the amount of maps that you can cover fully, and consequently which ones you can only reach the corner of. I didn't copy any of the other solutions, but still marked my solution with an orange star, as I feel this was such a big hint that the approach was already clear before I started.

I changed my code so I could run it multiple times using functions, and made it so I can switch between counting the even and the odd plots. Also, I wanted to be able to count a full map (without restricting the step count), and where I only wanted to count the corners (everything that's reachable after the 65 steps of the center). Also, we need to know the number of maps and corners we can cover. The first 65 steps in one direction are still on the first map. After that (the `remainingSteps` minus the `stepsToReachBorder`: `26501365 - 65 = 26501300`) we need to count the number of full maps. And `26501300` is exactly `202300` maps that are `131` plots wide. Then, drawing out a smaller sample, we learn that for this number which I called `mapReach`, the amount of odd and even tiles is clear as well as the amount of corners:

For even numbers of `mapReach`:
- we need `mapReach^2` maps of even steps counted (all even plots you can reach)
- we need `(mapReach + 1)^2` maps of odd steps counted (all odd plots you can reach)
- we need to add `mapReach` number of even steps in the corners (all even plots after 65 steps)
- we need to subtract `mapReach + 1` number of odd steps in the coners (all odd plots after 65 steps)

This works because you have the `mapReach` times 4 amount of actual corners that are added, but because a map has four corners, it's just `mapReach` amount of those maps to add. And there's also map corners you can't reach, but that are 4 corners more than the corners that are added, so we need to do `mapReach + 1`. And obviously count all the other plots (the odd ones).

For odd numbers of `mapReach` it's the other way around with odd and even and the +1, which for the puzzle input I didn't need to incorporate in my code, but I wanted it to be generic so I still included it.

And that's actually all there is to part 2. My solution (for the second time this AoC) doesn't work for all the examples given on the example input, but I didn't bother as that didn't have the same logic to it as the real input (where the amount of steps is an exact multiple of the map width and the map having such a distinguished diamond shape itself).