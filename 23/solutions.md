# Solutions to Day 23: A Long Walk

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

The solution to part 1 is quick simple, given the fact there aren't too many possible paths because of the slopes that allow only going in one direction. I've created a few classes to help me organize the input data (`Tile`, `TileType` and `Connection`) and looped over the input, creating tiles of the different indicated types. Then I looped over the two-dimensional array of tiles that form the map to record all connections, to eventually create a `TracePath()` function that uses recursion to discover all the possible paths to the end tile. My initial version worked well for part one and finished in roughly 18 seconds. But, when for part 2 I noticed this approach was going to take up way too much time, I've added an optimization: I added a function named `CollapseCorridors()` that iterates over the map to find all tiles that have exactly two connections and bridges that gap over that tile. The input data seems to have a lot of 'corridors': extendend collections of tiles that only have two adjacent tiles and effectively form a corridor heading to the next junction. This function I wrote joins all two-way connections to end up with a graph of 1-, 3- and 4-way connections. The actual puzzle input has about 18 3-way connections, 16 4-way connections, and almost 2.000 2-way connections. By joining the 2-way connections that do not have any other possible route than to follow the corridor they create, you actually bring back the amount of possibilities by a lot. My optimized part one solution now finished in 11 to 20 milliseconds!

## Part 2

For the second part of today's puzzle I started with removing a few things: I only needed to distinguish a path from a forest, so I removed the `TileType` enumeration and made it a boolean: either it's a path or it isn't. Then I simplified my connection creation part and furthermore I really didn't change anything. I am confident there are a lot of possible optimizations I didn't discover yet, but I thought I'd give it a go first. And when it finished in a little over half an hour, I was happy for today. NP-hard problems can't really be solved any other way than to brute-force them. I got my answer, and I didn't see any other obvious optimizations, so I left it at that.