# Solutions to Day 10: Pipe Maze

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

As I would need to iterate over the entire field multiple times (or `sketch` as the puzzle input is called) I started with reading the input, putting all tiles into a two-dimensional array. I created a `Pipe` class for such a tile to aid in storing all of the attributes of a tile, as there's a lot to keep track of per tile. Initially, at least the x- and y-coordinate, and the symbol within that tile. When I found the starting point while reading the input, I stored that into a separate `startingPoint` attribute for easy reference later on.

### Cleaning up the input sketch
All the clutter of those unconnected pipes bother me. Although maybe the algorithm would work without this step, it helped me a lot in understanding the assignments better, so I decided to first remove all unconnected pipes. And as it turned out, it did eventually incease the clarity of some parts of the code further on. To be able to do this, I added the booleans `north`, `east`, `south` and `west` to the `Pipe` class to store which directions are connected to other tiles. And I've added the private method `SetConnections()` to this class to set the correct values according to the given symbol from within the constructor. This way, I could iterate over all tiles in the `sketch` array and for each `Pipe` object count how many adjacent tiles contain a pipe with a connection *'to me'*. If the amount of connecting surrounding pipes was any other than 2, it couldn't be part of the loop, so I removed it. But, as to not invalidate my data set (I don't want to remove a tile that I need to check the connections of in the next row), I added a boolean to mark a pipe to be removed without actually changing the symbol *yet*. In another simple pass over the array I then used my `CleanUp()` method which closes all connections and changes the symbol to a '.' to empty the tile.

The funny thing is that this operation removed most of the unconnected pipes, but not all of them. And it makes sense when you think of it, as within the collection of unconnected pipes there are also partially connected paths, of which I now only removed the outer pipes. E.g., of three '|' symbols on top of each other, the middle one does have exactly two connections, although that chain isn't connected to the main loop. The simple solution here is to move my clean up code into a while loop and run it for as long as I can find unconnected pipes (which I've kept track of with the `incorrectPipesFound` boolean). A quick test showed me it only took two passes on one of the example inputs and only 5 passes in total for the actual puzzle input.

### Travelling through the pipes
There sure must be multiple ways of finding the furthest point in this main loop, but what seemed most elegant and easy to understand, was traversing the paths in both directions, and when both loops would land on the same tile, that would be the point that is as far as you can get from the starting point. I know the open connections of each tile, so I can just check which connection is open and move that way. But first I need to step away from the starting point 'S' that effectively has 4 open connections. So I need a separate piece of code for the first step as for all of the other ones. I simply check if the tile above me exists (index check) and if it has an open connection to the south (me), if so kick off the path traversing for path 1 in that direction. I have created a `Position` object with an x- and y-coordinate only for keeping track of where I am for each path. So I decrease the y-coordinate by 1 to step into a northerly direction. Then, I check the tile to my right, which should have an open connection east bound. If I already found an open connection before, that direction is for the second path, otherwise for the first path. Same for the tile below me. And the last tile to check, on my left, has to be for the second path as I need two connections and it can't be that the first path hasn't started yet.

Then, when I have advanced both paths one step away from the starting point, I can start iterating through the main loop. I start checking for an open connection in each direction again and when I have found one, I move that way. The only catch is that it shouldn't be the starting point, because I then would accidentally step back (the starting point has 4 open connections so you could step onto that from any other adjacent tile). So I check if my target tile doesn't contain the 'S'-symbol to make sure I keep following the correct path. And now comes a neat trick: in order to make sure I'm always advancing in the right direction, the moment that I step onto the new tile, I close the direction I came from for that pipe. I know where I came from, so I know which direction to close (if the open connection found is on the south, I should set the `north` value of the target pipe to false to close that connection). And now, when I will get in the next iteration of my loop, the current tile only has one open direction, meaning I will automatically move into the right direction! So, to summarize: each pipe always has two open connections, so when I close the direction I came from when stepping into the pipe, I only can come out in the other direction for the next iteration.

I then added a counter, increasing the `answer` value for each step along the path, to find the number of steps needed to get to the furthest point in the main loop. And as I step both paths at the same time (in the same loop) I only count one step for each of the paths advancing. Lastly, I simply break out of this loop when the x- and y-coordinate of both paths are equal. And that's my answer. By the way, I set my initial `answer` value to 1, because my loop starts after the first step away from the starting point.

## Part 2

Initially, the second part of today's puzzle threw me off for a bit. The fact that tiles could be enclosed by the outside edges of the main loop too, and the fact that you would be able to squeeze through touching pipes as well made it seem very difficult. On hindsight, that may have actually made the assignment easier, as they were clearly hinting at a 'point-in-polygon' algorithm, but I didn't see that at first. Another valid approach would be a flood fill algorithm, flooding from the outside in and counting all cells one didn't reach. But that would require adding extra tiles in-between all existing tiles (doubling the size of the two-dimensional array) to encounter for the 'squeeze-between-pipes'-behavior.

### Using a crayon to mark the inside of the path
Then, I started thinking, if I am walking around a path in a giant loop, the inside of that loop would always be on the same side, regardless of which direction I'm heading into. If I am walking clockwise (path 1) that would be on my right side, and when going counterclockwise (path 2) that's on my left. So I added booleans like `northInside`, `eastInside` etc. to the `Pipe` class. And then I have added some logic inside the already existing path traversing loop, to store which sides of each pipe can be marked as the inside of the loop. This took a lot of if-statements and felt sketchy, but I persisted: if I am on a '|'-symbol and I am going clockwise and I am moving north, the east side is the inside of the loop. If I am on that same position going south, the west side is the inside, but for the other path which is traversing in a counterclockwise direction, those values are reversed. Luckily, I only needed to mark the inside, and for corners that's only one direction for each path.

Now, each tile that contains a pipe has it's sides marked. So I added a loop going over all tiles again and if they were empty (which always is a '.' because I already removed the clutter) I started moving away from that tile in each wind direction until I hit a pipe. If all of the pipes I've found this way have their corresponding sides towards me marked as being the inside side of the path, I knew this tile would be within the main loop and I've set a boolean `inside` on that specific tile (or `Pipe` object as it's called in my code, although it also could be an empty tile).

Lastly, I needed one more pass over my `sketch` matrix to count all the inside tiles and add that to my `answer` and we're done!

#### Thoughts
*Looking back it does feel a bit procedural and it isn't the mathematical approach one would probably prefer. And also the code is a bit hard to follow with a multitude of direction checks, but it turned out to be very fast, and correct! So given the seemingly complex puzzle for today I was happy with the result nonetheless. If I would be given this assignment again though, I would probably opt for the point-in-polygon algorithm, counting the amount of crossings over the path (main loop) in any direction to see if it's an uneven number and if so I'm in the inside of the loop.*