# Solutions to Day 16: The Floor Will Be Lava

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

We've got a nice one again today! Not super complex to understand the assignment, but a decent amount of puzzling and coding to get it to work efficiently. This puzzle probably lends itself for some fancy pathfinding algorithms, but I chose the more simple and basic approach of creating beam objects and following their path over the grid. Though, my first attempt was way to bulky and slow, so I started again. Initially, I stepped one tile at a time per beam, but now I jump from mirror to mirror (or splitter of course). I also dropped a lot of helper objects and lists from my first attempt. And most importantly, I think my first attempt had a bug in there somewhere around the splitters, because the number of beams grew exponentially to well over 88 million. I thought this was intentional at first, one of those days that you cannot just follow the obvious route, but I quickly realized it was my fault. My second approach where I basically started from scratch only gets to 43 thousand beams in the end. Now, with my new, faster and bug-free version, part 1 finishes in only 54 ms and part 2 in under 5 seconds.

## Part 1

The first 'trick' for better efficiency was not creating a two-dimensional array, but reading the input file in rows, storing that in a string array, and then iterating over those rows to create a string array that contains all of the columns. A bit of an unconventional approach, but I felt this made my code easier to read and also more efficient, as I could move over the grid only using one string at a time (because you either move horizontally or vertically). My energized tiles array is a a two-dimensional array though, but using booleans instead of characters (as the puzzle example suggest), because this is a bit more effienct and also makes the code a little cleaner (when doing if-checks).

I've created a helper class called `Beam` to keep track of the x- and y-coordinate of each beam, as well as its direction. For the direction I created an enumeration for enhanced clarity. Then, I wrote a function named `FollowBeam()` that has a beam object both in its parameter list and as a return type: the input parameter is the current beam to follow, and the return object is for creating a new beam in case we hit a splitter (which is optional of course). This function starts with a check to see if we aren't outside of the grid, and then contains a large if-statement switching between the different directions. Not super charming but functional at least. For each direction, I iterate over the current row or column until I find a character that is relevant for that direction (skipping the `|` for vertical directions and the `-` for horizontal directions), marking each cell in between as being energized along the way. When I hit a relevant character (mirror or splitter), I change directions, update the coordinates of the beam object, and break out of the loop. This makes every step hopping from mirror to mirror (or splitter), instead of updating the beam position by one step at a time. If I hit a splitter, I let the current beam move in one direction, and return a new object that travels in the opposite direction. That's all for this function.

Then I've created a `List<Beam>()` object ot store my beams in, marked the starting position as energized, created the first beam, and started looping over the following:
- First, loop over the beams and call `FollowBeam()` for each beam. I check if it returns a new beam and if so, add it to a temporary list with `newBeams`, because I cannot alter my current list I'm looping over.
- Then I loop over all beams again to check if they moved off the grid, and if so, I remove them from the list.
- Only after that step, I iterate over the new beams to add and add them to the main list (I don't do that before removing beams for efficiency reasons, as I am sure I almost never have to remove a newly created beam - this can occur when a splitter is at the edges of the grid, but I rather do that clean up next time to be sure I am not iterating over the new beams for no reason).
- Now it's time to calculate the number of energized tiles. I simply iterate over the `energizedTiles[,]` array and count all marked cells. I store this in a temporary counter named `newAnswer`.
- How do you know you are ready? I was struggling with that. Clearly, not all beams run off the grid, some keep going in circles. My first attempt checked for beams going over the same tile in the same direction to remove them if so, but that was a super heavy check, because I also needed to store all former steps and directions, and go over that list for each beam for each step. From a logical point of view, that was the most elegant solution. I also tried to store snapshots of the grid and compare them with earlier iterations to see if anything changed. Obviously, that also was a very expensive check. Then it occured to me the amount of energized tiles has a direct correlation with the grid's state and is a perfect indicator for if the grid did change. So I started checking if the number of energized tiles was equal to those in the previous iteration. That didn't work though, as sometimes, when two beams are crossing, this number doesn't change for two consecutive steps. This behavior improved by not stepping per tile, but from mirror to mirror, but still my tests showed that this situation can occur. That's why I came up with a 'stability check'. I don't like the solution very much, but it works just fine. If the number of energized tiles doesn't change for more than 2 iterations, we can assume all beams are moving over their former path and no new information is added to the energized tiles array. So I compare the `newAnswer` to my previously stored `answer` and when those are equal, I increase the stability counter, otherwise I overwrite the `answer` value, and when my `stable` counter is greater than 2, I break out of the loop.

## Part 2

That's what I thought would happen... find the best position to start. Which means we basically need to run our code from part 1 for all edge tiles around the grid. It's a bit difficult to loop over the outside boundaries of a multi-dimensional array without a lot of if-statements, and I also needed to store the outcome of each starting position for later reference, so I opted for another helper class named `StartingPoint` that is a lot like the `Beam` class (x, y and direction) but also contains an integer value to store the `energizedTiles` count for that starting position. I created a `List<StartingPoint>()` and looped over both the x- and y-axis, creating both the zero-index and the last-index starting positions for each. This way I didn't need a lot of if-statements going around corners, and luckily you should also start in two directions from each corner, so I could just create duplicate entries by looping over the edges in each direction.

Now I just moved the whole of the core loop from part 1 into a `foreach` to run the code for each starting point and I only needed to set the initial `0, 0` coordinate and rightward direction to those of the starting point object, and store the outcome in the object instead of assigning it to the `answer` right away. After finishing looping over the starting points to calculate the amount of energized tiles, I looped over them again to set the `answer` to the energized tile count of that starting point if it was higher than my answer. And that was actually all there was too it. Not super fast, but reasonably quick. And it only took me 12 minutes to alter my code from part 1 to come up with the solution for part 2.