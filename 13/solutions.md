# Solutions to Day 13: Point of Incidence

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

After yesterday's puzzle, this one was a bit of a relief actually. It's quite fun, both the challenge itself and finding a proper solution. I first created the code to parse the input, I kept a List\<string>() called `pattern` for each pattern, adding the lines found to that, and once I hit a blank line (or the end of the input file) I processed that pattern block, which at the end also re-initialized the `pattern` object to start with a clean list for the next pattern block.

It seems way easier to cope with the horizontal lines than with the vertical ones, because you can just compare lines to each other using the `string.Equals()` function. And I wanted to only write one algorithm, so I started with doing horizontal lines only at first.

I've created a function named `analyzePattern()` that searches for anchors as I'd like to call them: any position (or index) where a pattern line equals the next line. So if there's at least one duplicate line, there potentially could be a reflection point. I do that by looping through the List\<string> and compare the current index with the next one, stopping one before the last index. I store those in `findAnchors`, a list of integers that represent indexes with the first occurence of a duplicate line. Then, this function calls `validateAnchor()` for each anchor found. If there are no anchors, or if none of them is valid, this function returns -1, indicating there is no reflection line in this pattern (and we probably should go looking for a vertical reflection line).

The `validateAnchor()` function finds the highest delta (the distance from the index to either the beginning or to the end of the list of lines of the current pattern), and starts looping over the lines, starting one below the given index, and comparing that with the line on the other side of the reflection, going both directions. E.g., for the anchor index 3, this `string.Equals()` functions compares 2 and 5, then 1 and 6, then 0 and 7. I don't have to check 3 and 4, because that was the anchor and I know that is going to match. It makes for a bit of a complex if statement in a loop, but this whole validation is only a few lines of code in the end. Mind that you also need to check if you go outside of the boundaries of the list, in that case, I ignore that line. And for that reason, it was easier to only return false when I found an invalid line, and if none of the checks would be invalid, I could return true at the end of the validation method.

Now the first valid anchor point that returns true, is also return by the `analyzePattern()` function. Plus one, because the puzzle wants to know the number of rows up to the reflection point, and the index of 3 as an anchor point has 4 rows up until the reflection line.

Back to the `processPattern()` function. I now _may_ have an answer, a valid pattern note. And horizontal lines should be multiplied by 100, so I do that right away. That's why I used the negative integer -1 to signal not having found a valid anchor, because that can be multiplied without losing its invalidity marker. If a valid anchor was found, I have my result right away, 400 in this case. If I didn't find one, the current pattern note equals -100. So, if my pattern note value is negative, I need to start looking vertically. As I said, I wanted to re-use my logic, so I created a `rotate()` function that rotates mirror, and with that the whole pattern block, clockwise. It's a simple loop over all characters, flipping the x and y coordinates. Now, I can call my `analyzePattern()` function _again_. And now I know it will come up with an answer. That I don't have to mulitple, so I just assign its outcome to `patternNote` and add that to my answer. I reset my pattern storage for the next block and that's it. I think this solution is quite elegant and efficient.

## Part 2

It took me a while to realize the new reflection point _has_ to be different (the assignment is to find a _different reflection line_, though it also states that the old reflection line won't necessarily continue to be valid, but that isn't really relevant anymore). There is one more reason you cannot hold on to the old reflection line: any line that is not reflected in the given pattern (falling outside of the pattern) allows for all characters to be different. So that would invalidate the whole puzzle. This made me think, what if I store the outcome of the original `analyzePattern()` function, and then start looping over the whole pattern while flipping symbols one by one, looking for new anchor points and validate them as long as they're different than the initial one. And that's what I ended up doing, and what turned out to work quite well - and fast too. I didn't like the brute force feel to it, but I couldn't see how you would do it otherwise given my existing algorithm.

I added an optional input parameter for `analyzePattern()` so I could supply my old pattern note, that would skip this anchor (minus one, because I need to go back to the original index and a pattern note of 4 means index 3 of the first anchor line). It is optional, because I also still want to use this method to retrieve my original anchor point.

Then I've added a function called `findSmudge()` that does all the dirty work: loop over the pattern, change a character one by one, analyze each outcome, and return a reflection line if found with the corrected mirror. Because there is always exactly one smudge, this approach works very well and I can return a result on the first hit.

Now for some trickery: in `processPattern()` I retrieve both the original note using `analyzePattern()` and the potentially new note using `findSmudge()` that also indirectly uses the analyze pattern function but tries all possibilities and ignores the original reflection line. If I now found something I'm already done. The new line after correcting the smudge is a horizontal one. If not, I rotate. Same as before. But now, if the `oldPatternNote` was negative, it _originally_ also was a vertical line, so than I need to get my original note again by calling `analyzePattern()` on the now rotated mirror. If the `oldPatternNote` from the beginning of the current pattern processing wasn't negative, the original line was horizontal, and I can ignore any previous value, because there was no vertical line, so I make `oldPatternNote` -1 to disable this functionality. Any variation now would produce a valid outcome for the new vertical reflection point.

_Edit: after finishing the puzzle, I came up with the idea of 'folding' over a pattern over each line between two rows, and then checking if the overlapping rows are equal. This would also allow for counting deviations. And if there's only one, you have found the alternative line. This algorithm might be even more efficient than my initial approach._  