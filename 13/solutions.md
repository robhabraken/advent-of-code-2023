# Solutions to Day 13: Point of Incidence

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

After yesterday's puzzle, this one was a bit of a relief actually. It was quite fun, both the challenge itself and finding a proper solution. I first created the code to parse the input, I kept a List\<string>() called `pattern` for each pattern, adding the lines found to that, and once I hit a blank line (or the end of the input file) I processed that pattern block, which at the end also re-initialized the `pattern` object to start with a clean list for the next pattern block.

It seems way easier to cope with the horizontal lines than with the vertical ones, because you can just compare lines to each other using the `string.Equals()` function. And I wanted to only write one algorithm, so I started with doing horizontal lines only at first.

The `validate()` function finds the highest delta of a given reflection line (the distance from the index to either the beginning or to the end of the list of lines of the current pattern), and starts looping over the lines, starting one below the given index, and comparing that with the line on the other side of the reflection, going both directions. E.g., for the index 3, this `string.Equals()` functions compares lines 2 and 5, then 1 and 6, then 0 and 7. It makes for a bit of a complex if statement in a loop, but it's a very effective little piece of code to check the validity of a given reflection point like so. Mind that you also need to check if you go outside of the boundaries of the list, in that case, I ignore that line. And for that reason, it was easier to only return false when I found an invalid line, and if none of the checks would be invalid, I could return true at the end of the validation method (instead of keeping track if everything was still valid across none existing reflections).

Then, the function `analyzePattern()` uses that validation function to search for the first occuring valid reflection (and because there's only one, that suffices). I just loop over the indexes to find the reflection and then return that value. Plus one, because the puzzle wants to know the number of rows up to the reflection point, and the index of 3 is my anchor, which has 4 rows up until the reflection line.

Back to the `processPattern()` function. I now _may_ have an answer, a valid pattern note. And because horizontal lines should be multiplied by 100, I do that right away. That's why I used the negative integer -1 to signal not having found a valid reflection line, because that can be multiplied without losing its 'invalidity marker'. If a valid reflection line was found, I have my result right away, 400 in this case. If I didn't find one, the current pattern note equals -100. So, if my pattern note value is negative, I need to start looking vertically. As I said, I wanted to re-use my logic, so I created a `rotate()` function that rotates the whole pattern block clockwise. It's a simple loop over all characters, flipping the x and y coordinates. Now, I can call my `analyzePattern()` function _again_. And now I know it will come up with an answer (because if there was no horizontal line, there has to be a vertical reflection line). That I don't have to multiply, so I just assign its outcome to `patternNote` and add that to my answer. I think this solution came out to be very elegant and efficient.

## Part 2

It took me a while to realize the new reflection point _has_ to be different (the assignment is to find a _different reflection line_, though it also states that the old reflection line won't necessarily continue to be valid, but that isn't really relevant anymore). There is one more reason you cannot hold on to the old reflection line: any line that is not reflected in the given pattern (falling outside of the pattern) allows for all characters to be different. So that would invalidate the whole puzzle. So I've added a parameter named `skipReflectionLine` that defaults to -1 to the `analyzePattern()` function, so I could tell that function to ignore that specific reflection line if I wanted to. In the if-statement of that function, I just checked if the reflection line I would be going to test against the validation function wasn't equal to that (minus one, again, because the index is one lower that the pattern note the puzzle description asks for).

Then, I also changed my `validate()` function, because I couldn't use `string.Equals()` anymore, because I have to allow exactly one deviation. So I changed this line to a loop going over all of the characters in both strings and keeping a counter (across lines!) to see if I have more than one difference. But I did use an input parameter for that too, because I also wanted to get the original reflection line using the logic from part 1 (thus 0 differences).

Now I could extend the `processPattern()` function: I first retrieve the original reflection line by allowing 0 differences. Then, I get the potentially new pattern note allowing 1 difference, but skipping the old pattern note (aka reflection line). If I would find that new reflection line (times 100), I'm done. If the pattern note is negative, I have to go looking vertically (that part hasn't changed). So I rotate, and then comes a little trick: if my old pattern note was negative to start with, the original reflection line would've been vertical as well, meaning I need to again get the new old reflection line on the now rotated pattern. Otherwise, I have to do the opposite and make the old pattern note negative, so it won't influence my new attempt to look for a reflection with exactly 1 deviation. A negative old pattern note would disable this functionality (to not accidentally compare the old horizontal line with the new vertical one, which would lead to incorrect answers).
