# Solutions to Day 24: Never Tell Me The Odds

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

This one seemed challenging at first, but I was able to solve part 1 all by myself in a reasonable amount of time. In the end, there's not much to explain as it is basic algebra. Though my first formula to calculate the intersection of two lines turned out to have a rounding issue that didn't occur for the example input, and made the output for the real puzzle input look viable still, so it took me a while to figure this out. Other than that, it's straightforward: created a helper class `Coord` and `Hailstone` to store the input in, and added a `IntersectsWith()` function to the latter to calculate the intersection point between another hailstone and the current one. Then check if it the point found lies within the given bounds, and that it lies in the future for both hailstones. I have created a separate function `IsInFuture()` for that for clarity, that basically just checks per axis if, if the velocity is positive, the coordinate found is greater than the starting position and visa versa.

Then I looped through the list of given hailstones and counted all that returned `true` when calling this intersect function. The intersect function by the way requires two points to calculate the slope, which is done by also using the position after one nanosecond (adding the velocity to the starting position).

## Part 2

The second part threw me off. To visualize and graps the concept in the first place, let alone the mathematics required. Also because we need to take 4 dimensions into account: each hailstone will be hit at a different point in time, so each hailstone has an n-amount of velocity deltas added to its starting position, but you do not know which hailstone you are going to hit in which order. And we need to find no less than 6 variables. This really seemed the hardest concept of this year's AoC. I first started playing around and trying some stuff, brute-force, looking at input data, looking for patterns, and trying to reverse engineer the example answer to the example input.

After a few attempts, I was scrolling through the AoC subreddit. Not to copy code, but to read some ideas and approaches on how to cope with this seemingly impossible assignment. Then I saw somebody mentioning that there are quite a few equally fast moving hailstones per individual axis, and in order to be able to hit them all with your rock at subsequent nanoseconds (integer increments of their velocity), the difference in velocity between the hailstones and the rock should have a remainder of zero when dividing the distance between a pair of equally fast moving hailstones.

That's a concept I can understand and work out myself! So I created a sorted list of the hailstones per axis, and looped through them looking for hailstones that moved equally fast along a given axis. Since all velocities where in the range of roughly -500 to 500, I iterated over a possible velocity for the rock between -1000 and 1000, checking each velocity on each axis against all equally fast moving pairs per axis. This only took around 16 ms and where I expected to find a small list of possible velocities that I needed to do further tests on, surprisingly, each axis only had one possible velocity that would work with all hailstones. The larger dataset is helping here, as the example input only has a definite answer on the x-axis using this method.

Then I could reuse my initial `IntersectsWith()` function and renamed it to `PositionRock()`. Instead of determining the slopes using two points on a given line to find the intersection between two hailstone trajectories, I now used the velocity of the rock as the second 'point' compared to the hailstones' velocities. This also gives two slopes, not along the path of the hailstone, but from both intersection points of each hailstone with the rock towards the joint origin of the rock trajectory. The intercepts are equal to the original intersect function, and the position then calculated is not the intersection point between the lines, but the origin of the rock. Now we only needed to add finding the position on the z-axis. We now know the (x) position of both the rock and (one of) the hailstones, so we can work out the time passed from the origin to the intersection point with a hailstone by dividing the position difference by the velocity difference. Then, multiplying the difference in z-velocity with the time, adding it to the starting position of said hailstone, gives us the starting position of our rock.

I honestly couldn't have done this with the help of such a useful insight, but was happy to being able to actually implement the idea myself and still learn a lot again today.