# Solutions to Day 7: Camel Cards

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

I liked this one a lot! Not overly complex, but very fun to do. My first observation was that I needed some classes to help me structuring my solution. I've created an enumeration for the hand types (high card, one pair etc.) in order of value, so I could use that for sorting on later. And a `Card` class containing both a list of actual values, and a corresponding list of alphabetic letters in reverse order. Since each card value is represented by a single `char` value, I didn't bother using a collection type, as a simple string is also a perfect collection of char values. So my card value string is `23456789TJQKA` and the corresponding `SORT_VALUE` string is `MLKJIHGFEDCBA`. This way, I can read the value from the card and replace it with the corresponding sorting value by retrieving the character from the `SORT_VALUE` attribute using the same index as the input card value. By doing so, my sorting algorithm is going to be way cleaner as I can use regular alphabetic sorting. No need for if-statements or comparing those strange card value characters.

Then, I've built the `Hand` class, representing a single hand. This turned out to be the majority of the work. A Hand object contains the input string named `Cards`, an integer value for the corresponding `Bid`, and a `HandType` instance that I will add myself. I've written a `DiscoverType()` function to determin the hand type based on the cards input string. To do this, I came up with something I call an `occurrenceMap`: a string (again, using a string as a collection here, but now for integers) to store the count per card type. So where the `Card.VALUES` attribute contains a list of all cards (`23456789TJQKA`), my `occurrenceMap` would be `1200000010010` for the hand `32T3K`. I've created a helper method `CountOccurrences()` that counts the number of occurrences for a single char value, and then call that in a simple single line loop for all characters from the hand input string. This `occurrenceMap` makes it super easy to determine the hand type: if it contains any `5` (using the `string.Contains()` method), it's Five of a kind, if it contains a `4`, it's Four of kind. If it contains a `3` *AND* a `2` it's a Full house and else if it just contains a `3` it's Three of a kind. Et cetera. I'm not sure if it is any more sufficient than other solutions but I liked the efficiency and cleanliness of it.

Now, there's only two more things to add to my `Hand` class. First, a `GetSortValue()` method to translate the actual card values into a sortable string (so `32T3K` would become `LMELB` for example). Secondly, I implemented the IComparable interface and added a `CompareTo()` function to my Hand class. If the hand type would be the same, I would compare the sort values of both cards alphabetically. Otherwise, I would sort on `HandType`. And because the latter is an enumeration that has increasing indexes values corresponding to their sort values (or actual value), that works too. By the way, this way of sorting hands only works for the rules given in this puzzle, as the first card in your hand determines the value of your hand, and if they would be equal, the second one does, etc. That's just like how alphabetic sorting works. But in the real world card games mostly aren't valueing hands like this of course.

Having prepared everything this well, I was surprised myself that the actual code needed to come up with the answer only was a few lines: simply calling `hands.Sort()` on my List\<Hand> collection that I've parsed and processed, and then one single line loop to go over my sorted hands, multiplying their bid values with the index within the collection and adding the result to my `answer`. Very happy and satisfied with how clean and nice this solution turned out!

## Part 2

At first, this seemed to be complex, because you need to come up with the highest possible hand for a random amount of jokers. How are you going to assign them? After pondering over a cup of coffee it suddenly occurred to me: adding the jokers to the card that occurs most in your hand always gives you the highest value! If you have a four of a kind, that'll give you five of a kind. If you have a three of a kind, that'll make it four or five of a kind. And even for a high card, it'll produce everything from a single pair to five of a kind. So I just added two loops to my `DiscoverType()` function: one to find the highest number in my `occurrenceMap` and one to add the amount of jokers found (position 0 in my ocurrence map) to the position of the highest number. And if it would contain multiple equal values (like two pairs, or in case of a high card five times a 1, or in case of all jokers, all zeros) it would work just fine, as it adds the jokers to the first occurrence of that high value. For our hand value it doesn't matter to which other card you've add the jokers in case of equal occurrences. Why is that? Because the joker is valued lowest in a comparison of equal hand types, as the puzzle input states! So if you would have two hands that are both a Two pair type of hand with a joker, e.g. `55JKK` and `KK3J3` it would add the left hand joker to the 5's and the right and joker to the Kings. Intuitively, you would like to add the jokers to the Kings in both hands so the left hand has a higher value in total. But for this puzzle today, that doesn't apply. The hands both would become a Full house hand, and they would be compare on the first card in each hand, so the left one is going to end up lower anyway. This means I can keep my algorithm simple: just add the joker to the first occurrence of the highest occurrence. This even took more lines to explain than to code :-)...

After re-assigning the jokers, there's only one small thing left to do: change the card value attribute from `23456789TJQKA` to `J23456789TQKA`, as the J now is a Joker and no longer a Jack, and it is valued lowest. As you might have seen, I didn't change the `Card` string value of the puzzle input, so my cards could still be sorted using the original value. The only thing I did to account for the jokers is changing the `occurrenceMap`, effectively changing the hand type following from that.

This certainly doesn't happen to me every day of the Advent of Code event, but I think that the fact that I didn't need to change a lot for the second part of the puzzle proved my setup was sound today. And I liked the tricks I came up with for the sorting and counting the occurrences, so I had a lot of fun today!
